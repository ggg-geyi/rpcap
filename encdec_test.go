package rpcap

import (
	"bytes"
	"io"
	"io/ioutil"
	"os"
	"reflect"
	"testing"

	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
	"github.com/google/gopacket/pcapgo"
)

var tests = map[int]Message{
	1:  &AuthRequest{Header: Header{Version: 0x0, Type: 0x8, Value: 0x0, pLength: 0x8}, Type: 0x0, Dummy: 0x0, sLen1: 0x0, sLen2: 0x0, FirstAuthItem: []uint8(nil), SecondAuthItem: []uint8(nil)},
	2:  &AuthReply{Header: Header{Version: 0x0, Type: 0x88, Value: 0x0, pLength: 0x0}},
	3:  &FindAllInterfaceRequest{Header: Header{Version: 0x0, Type: 0x2, Value: 0x0, pLength: 0x0}},
	4:  &OpenRequest{Header: Header{Version: 0x0, Type: 0x3, Value: 0x0, pLength: 0x32}, Interface: "\\Device\\NPF_{C4C36556-2040-41FE-B5EC-63973C9F0C01}"},
	5:  &OpenReply{Header: Header{Version: 0x0, Type: 0x83, Value: 0x0, pLength: 0x8}, LinkType: 0x1, Timezone: 0},
	6:  &CloseMsg{Header: Header{Version: 0x0, Type: 0x6, Value: 0x0, pLength: 0x0}},
	7:  &AuthRequest{Header: Header{Version: 0x0, Type: 0x8, Value: 0x0, pLength: 0x18}, Type: 0x1, Dummy: 0x0, sLen1: 0x8, sLen2: 0x8, FirstAuthItem: []uint8("username"), SecondAuthItem: []uint8("password")},
	8:  &ErrorMsg{Header: Header{Version: 0x0, Type: 0x1, Value: 0x3, pLength: 0x33}, Description: "Logon failure: unknown user name or bad password.\r\n"},
	9:  &StartCaptureRequest{Header: Header{Version: 0x0, Type: 0x4, Value: 0x0, pLength: 0x1c}, SnapLength: 0x40000, ReadTimout: 0x7d, Flags: 0x1, Port: 0x0, Filter: Filter{Type: 0x1, Dummy: 0x0, ItemsCount: 0x1, Data: []uint8{0x0, 0x6, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0}}},
	10: &StartCaptureReply{Header: Header{Version: 0x0, Type: 0x84, Value: 0x0, pLength: 0x8}, Bufsize: 256000, Port: 1041, Dummy: 0x0},
	11: &StatsRequest{Header: Header{Version: 0x0, Type: 0x9, Value: 0x0, pLength: 0x0}},
	12: &StatsReply{Header: Header{Version: 0x0, Type: 0x89, Value: 0x0, pLength: 0x10}, IfRecv: 313586, IfDrop: 15205120, KrnlDrop: 29830, SvrCapt: 282435},
	13: &SetSamplingRequest{Header: Header{Version: 0x0, Type: 0xb, Value: 0x0, pLength: 0x8}, Method: 0x1, Dummy1: 0x0, Dummy2: 0x0, Value: 0x8},
	14: &SetSamplingReply{Header: Header{Version: 0x0, Type: 0x8b, Value: 0x0, pLength: 0x0}},
	15: &UpdateFilterRequest{Header: Header{Version: 0x0, Type: 0x5, Value: 0x0, pLength: 0x160}, Filter: Filter{Type: 0x1, Dummy: 0x0, ItemsCount: 0x2b, Data: []uint8{0x0, 0x28, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc, 0x0, 0x15, 0x0, 0x28, 0x0, 0x0, 0x8, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x0, 0x15, 0x0, 0x2, 0x7f, 0x0, 0x0, 0x1, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1e, 0x0, 0x15, 0x3, 0x24, 0xac, 0x10, 0x0, 0x1, 0x0, 0x15, 0x0, 0x23, 0xac, 0x10, 0x0, 0x1, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1e, 0x0, 0x15, 0x0, 0x21, 0x7f, 0x0, 0x0, 0x1, 0x0, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x17, 0x0, 0x15, 0x2, 0x0, 0x0, 0x0, 0x0, 0x84, 0x0, 0x15, 0x1, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x15, 0x0, 0xa, 0x0, 0x0, 0x0, 0x11, 0x0, 0x28, 0x0, 0x0, 0x0, 0x0, 0x0, 0x14, 0x0, 0x45, 0x8, 0x0, 0x0, 0x0, 0x1f, 0xff, 0x0, 0xb1, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe, 0x0, 0x48, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe, 0x0, 0x15, 0x0, 0x2, 0x0, 0x0, 0xc0, 0xbc, 0x0, 0x48, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x15, 0x15, 0x3, 0x0, 0x0, 0x7, 0xd2, 0x0, 0x15, 0x0, 0x2, 0x0, 0x0, 0x7, 0xd2, 0x0, 0x48, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x15, 0x12, 0x0, 0x0, 0x0, 0xc0, 0xbc, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a, 0x0, 0x15, 0x0, 0x2, 0x7f, 0x0, 0x0, 0x1, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1e, 0x0, 0x15, 0x3, 0xf, 0xac, 0x10, 0x0, 0x1, 0x0, 0x15, 0x0, 0xe, 0xac, 0x10, 0x0, 0x1, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1e, 0x0, 0x15, 0x0, 0xc, 0x7f, 0x0, 0x0, 0x1, 0x0, 0x30, 0x0, 0x0, 0x0, 0x0, 0x0, 0x17, 0x0, 0x15, 0x2, 0x0, 0x0, 0x0, 0x0, 0x84, 0x0, 0x15, 0x1, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x15, 0x0, 0x8, 0x0, 0x0, 0x0, 0x11, 0x0, 0x28, 0x0, 0x0, 0x0, 0x0, 0x0, 0x14, 0x0, 0x45, 0x6, 0x0, 0x0, 0x0, 0x1f, 0xff, 0x0, 0xb1, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe, 0x0, 0x48, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe, 0x0, 0x15, 0x2, 0x0, 0x0, 0x0, 0xc0, 0xc5, 0x0, 0x48, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x15, 0x0, 0x1, 0x0, 0x0, 0xc0, 0xc5, 0x0, 0x6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0}}},
	16: &UpdateFilterReply{Header: Header{Version: 0x0, Type: 0x85, Value: 0x0, pLength: 0x0}},
	17: &SetSamplingRequest{Header: Header{Version: 0x0, Type: 0xb, Value: 0x0, pLength: 0x8}, Method: 0x2, Dummy1: 0x0, Dummy2: 0x0, Value: 1000},
	18: &FindAllInterfaceReply{Header: Header{Version: 0x0, Type: 0x82, Value: 0x2, pLength: 0x6fe},
		InterfaceList: []InterfaceInfo{
			InterfaceInfo{nameLength: 0x32, descLength: 0x41, Flags: 0, numberOfAddr: 0x1, Dummy: 0x0,
				Name:        []byte("\\Device\\NPF_{C4C36556-2040-41FE-B5EC-63973C9F0C01}"),
				Description: []byte("AMD PCNET Family Ethernet Adapter (Microsoft's Packet Scheduler) "),
				Addresses:   [][512]uint8{[512]uint8{0x0, 0x2, 0x0, 0x0, 0xa, 0x0, 0x2, 0xf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}}},
			InterfaceInfo{nameLength: 50, descLength: 65, Flags: 0, numberOfAddr: 0x2, Dummy: 0x0,
				Name:        []byte("\\Device\\NPF_{7F9991C3-4C67-4DBE-80AC-1E72900C22D2}"),
				Description: []byte("AMD PCNET Family Ethernet Adapter (Microsoft's Packet Scheduler) "),
				Addresses: [][512]byte{
					[512]byte{0x00, 0x02, 0x00, 0x00, 0x64, 0x64, 0x64, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
					[512]byte{00, 0x02, 0x00, 0x00, 0xac, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00},
				},
			},
		},
	},
}

func openFile(name string, t *testing.T) (*os.File, *pcapgo.Reader) {
	infile, err := os.Open(name)
	if err != nil {
		t.Fatalf("Unable to open input file: %s\n", err)
	}

	r, err := pcapgo.NewReader(infile)
	if err != nil {
		t.Fatalf("PCAPGO unable to open input file: %s\n", err)
	}

	return infile, r
}

func readPacketsTCPPayload(r *pcapgo.Reader, t *testing.T) (readers []io.Reader) {
	for {
		data, _, err := r.ReadPacketData()
		if err == io.EOF {
			break
		}
		if err != nil {
			t.Fatalf("Error read packet: %s\n", err)
		}
		packet := gopacket.NewPacket(data, layers.LayerTypeEthernet, gopacket.Default)
		tcpLayer := packet.Layer(layers.LayerTypeTCP)
		tcp, _ := tcpLayer.(*layers.TCP)
		if tcp != nil {
			readers = append(readers, bytes.NewReader(tcp.Payload))
		}
	}

	return readers
}

func TestDecoder(t *testing.T) {
	infile, r := openFile("./golden/rpcap_only2.pcap", t)
	defer infile.Close()

	var pr io.Reader
	var packetCount int
	//for packetCount = 0; pr != nil; packetCount++ {

	for packetCount, pr = range readPacketsTCPPayload(r, t) {
		packetCount++
		decoder := NewDecoder(pr)
		have, err := decoder.Decode()
		switch {
		case err != nil:
			t.Errorf("Packet #%d: decode error %s", packetCount, err)
			t.Logf("Packet #%d: %#v", packetCount, have)
		case !reflect.DeepEqual(tests[packetCount], have):
			t.Errorf("Packet #%d:", packetCount)
			t.Errorf("\texpect: %#v", tests[packetCount])
			t.Errorf("\t  have: %#v", have)
			//t.Error(pretty.Compare(tests[packetCount], have))
			//default:
			//	t.Logf("Packet #%d: %#v", packetCount, have)
		}
	}

	if packetCount != len(tests) {
		t.Errorf("Read not all packets from file: read %d, have %d", packetCount, len(tests))
	}
}

func TestEncoder(t *testing.T) {
	infile, r := openFile("./golden/rpcap_only2.pcap", t)
	defer infile.Close()

	var pr io.Reader
	var packetCount int
	//for packetCount = 0; pr != nil; packetCount++ {

	for packetCount, pr = range readPacketsTCPPayload(r, t) {
		packetCount++
		expect, _ := ioutil.ReadAll(pr)

		var wr bytes.Buffer
		encoder := NewEncoder(&wr)
		err := encoder.Encode(tests[packetCount])
		have := wr.Bytes()

		switch {
		case err != nil:
			t.Errorf("Packet #%d (%s): encode error %s", packetCount, reflect.TypeOf(tests[packetCount]), err)
			t.Logf("Packet #%d: %#v", packetCount, have)
		case !reflect.DeepEqual(expect, have):
			t.Errorf("Packet #%d (%s): ", packetCount, reflect.TypeOf(tests[packetCount]))
			t.Errorf("\texpect %#v", expect)
			t.Errorf("\t  have %#v", have)
			//t.Error(pretty.Compare(tests[packetCount], have))
			//default:
			//	t.Logf("Packet #%d: %#v", packetCount, have)
			//	_ = tests
		}
	}

	if packetCount != len(tests) {
		t.Errorf("Read not all packets from file: read %d, have %d", packetCount, len(tests))
	}
}
